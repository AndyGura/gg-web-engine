interface TopLevelFunctions {
  [Value] static btVector3 quatRotate_([Const, Ref] btQuaternion rotation, [Const, Ref] btVector3 v);
  static void set_gContactAddedCallback(VoidPtr cb);
};

interface AdapterFunctions {
  static void setInternalTickCallback(btDynamicsWorld world, VoidPtr cb, optional VoidPtr worldUserInfo, optional boolean isPreTick);
};

interface Clone {
  static btVector3 Vector3([Const, Ref] btVector3 v);
  static btQuaternion Quaternion([Const, Ref] btQuaternion q);
};

// Linear Math

interface btIDebugDraw {
  void drawLine([Const, Ref] btVector3 from, [Const, Ref] btVector3 to, [Const, Ref] btVector3 color);
  void drawContactPoint([Const, Ref] btVector3 pointOnB, [Const, Ref] btVector3 normalOnB, float distance, long lifeTime, [Const, Ref] btVector3 color);
  void reportErrorWarning([Const] DOMString warningString);
  void draw3dText([Const, Ref] btVector3 location, [Const] DOMString textString);
  void setDebugMode(long debugMode);
  long getDebugMode();
};

[JSImplementation="btIDebugDraw"]
interface DebugDrawer {
  void DebugDrawer();
  void drawLine([Const, Ref] btVector3 from, [Const, Ref] btVector3 to, [Const, Ref] btVector3 color);
  void drawContactPoint([Const, Ref] btVector3 pointOnB, [Const, Ref] btVector3 normalOnB, float distance, long lifeTime, [Const, Ref] btVector3 color);
  void reportErrorWarning([Const] DOMString warningString);
  void draw3dText([Const, Ref] btVector3 location, [Const] DOMString textString);
  void setDebugMode(long debugMode);
  [Const] long getDebugMode();
};

interface btVector3 {
  void btVector3();
  // void btVector3([Const, Ref] btVector3 v);
  void btVector3(float x, float y, float z);
  float length();
  float x();
  float y();
  float z();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setValue(float x, float y, float z);
  void normalize();
  [Value] btVector3 normalized();
  [Value] btVector3 rotate([Const, Ref] btVector3 wAxis, [Const] float angle);
  float dot([Ref] btVector3 v);
  float angle([Const, Ref] btVector3 v);
  [Value] btVector3 absolute();
  [Value] btVector3 cross([Const, Ref] btVector3 v);
  float triple([Const, Ref] btVector3 v1, [Const, Ref] btVector3 v2);
  long minAxis();
  long maxAxis();
  long furthestAxis();
  long closestAxis();
  void setInterpolate3([Const, Ref] btVector3 v0, [Const, Ref] btVector3 v1, float rt);
  // [Value] btVector3 lerp([Const, Ref] btVector3 v, [Const, Ref] float t);
  [Operator="*=", Ref] btVector3 op_mul(float x);
  [Operator="+=", Ref] btVector3 op_add([Ref] btVector3 v);
  [Operator="-=", Ref] btVector3 op_sub([Ref] btVector3 v);
};

interface btVector4 {
  void btVector4();
  void btVector4(float x, float y, float z, float w);
  float w();
  [Value] btVector4 absolute4();
  long maxAxis4();
  long minAxis4();
  long closestAxis4();
  [Operator="="] void op_set([Const, Ref] btVector4 v);
  
  // cannot be included because btVector4 doesn't implement btVector3::setValue(x, y, z)
  // void setValue(float x, float y, float z, float w);

  float length();
  float x();
  float y();
  float z();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void normalize();
  [Value] btVector3 normalized();
  [Value] btVector3 rotate([Const, Ref] btVector3 wAxis, [Const] float angle);
  float dot([Ref] btVector3 v);
  float angle([Const, Ref] btVector3 v);
  [Value] btVector3 absolute();
  [Value] btVector3 cross([Const, Ref] btVector3 v);
  float triple([Const, Ref] btVector3 v1, [Const, Ref] btVector3 v2);
  long minAxis();
  long maxAxis();
  long furthestAxis();
  long closestAxis();
  void setInterpolate3([Const, Ref] btVector3 v0, [Const, Ref] btVector3 v1, float rt);
  // [Value] btVector3 lerp([Const, Ref] btVector3 v, [Const, Ref] float t);
  [Operator="*=", Ref] btVector3 op_mul(float x);
  [Operator="+=", Ref] btVector3 op_add([Ref] btVector3 v);
  [Operator="-=", Ref] btVector3 op_sub([Ref] btVector3 v);
};
// //btVector4 implements btVector3;

interface btQuadWord {
  float x();
  float y();
  float z();
  float w();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setW(float w);
};

interface btQuaternion {
  void btQuaternion();
  // void btQuaternion([Const, Ref] btQuaternion q);
  void btQuaternion(float x, float y, float z, float w);
  void setValue(float x, float y, float z, float w);
  void setEulerZYX(float z, float y, float x);
  void setRotation([Ref] btVector3 axis, float angle);
  void normalize();
  float length2();
  float length();
  float dot([Ref] btQuaternion q);
  [Value] btQuaternion normalized();
  [Value] btVector3 getAxis();
  [Value] btQuaternion inverse();
  float getAngle();
  float getAngleShortestPath();
  float angle([Ref] btQuaternion q);
  float angleShortestPath([Ref] btQuaternion q);
  [Operator="+=", Ref] btQuaternion op_add([Ref] btQuaternion q);
  [Operator="-=", Ref] btQuaternion op_sub([Ref] btQuaternion q);
  [Operator="*=", Ref] btQuaternion op_mul(float s);
  [Operator="*=", Ref] btQuaternion op_mulq([Ref] btQuaternion q);
  [Operator="/=", Ref] btQuaternion op_div(float s);
};
btQuaternion implements btQuadWord;

interface btMatrix3x3 {
  void setEulerZYX(float ex, float ey, float ez);
  void getRotation([Ref] btQuaternion q);
  [Value] btVector3 getRow(long y);
};

interface btTransform {
  void btTransform();
  void btTransform([Ref] btQuaternion q, [Ref] btVector3 v);

  void setIdentity();
  void setOrigin([Ref] btVector3 origin);
  void setRotation([Ref] btQuaternion rotation);
  [Ref] btVector3 getOrigin();
  [Value] btQuaternion getRotation();
  [Ref] btMatrix3x3 getBasis();
  void setFromOpenGLMatrix(float[] m);
  [Value] btTransform inverse();
  [Operator="*=", Ref] btTransform op_mul([Ref] btTransform t);
};

interface btMotionState {
  void getWorldTransform([Ref] btTransform worldTrans);
  void setWorldTransform([Ref] btTransform worldTrans);
};

[JSImplementation="btMotionState"]
interface MotionState {
  void MotionState();
  [Const] void getWorldTransform([Ref] btTransform worldTrans);
  void setWorldTransform([Const, Ref] btTransform worldTrans);
};

interface btDefaultMotionState {
  void btDefaultMotionState([Ref] optional btTransform startTrans, [Ref] optional btTransform centerOfMassOffset);
  [Value] attribute btTransform m_graphicsWorldTrans;
};
btDefaultMotionState implements btMotionState;

interface btSpatialForceVector {
	[Value] attribute btVector3 m_topVec;
  [Value] attribute btVector3 m_bottomVec;
	//
	void btSpatialForceVector();
	void btSpatialForceVector([Const, Ref] btVector3 angular, [Const, Ref] btVector3 linear);
	// void btSpatialForceVector([Const, Ref] float ax, [Const, Ref] float ay, [Const, Ref] float az, [Const, Ref] float lx, [Const, Ref] float ly, [Const, Ref] float lz);
	//
	void setVector([Const, Ref] btVector3 angular, [Const, Ref] btVector3 linear);
	// void setValue([Const, Ref] float ax, [Const, Ref] float ay, [Const, Ref] float az, [Const, Ref] float lx, [Const, Ref] float ly, [Const, Ref] float lz);
	//
	void addVector([Const, Ref] btVector3 angular, [Const, Ref] btVector3 linear);
	// void addValue([Const, Ref] float ax, [Const, Ref] float ay, [Const, Ref] float az, [Const, Ref] float lx, [Const, Ref] float ly, [Const, Ref] float lz);
	//
	[Const, Ref] btVector3 getLinear();
	[Const, Ref] btVector3 getAngular();
	//
	void setLinear([Const, Ref] btVector3 linear);
	void setAngular([Const, Ref] btVector3 angular);
	//
	void addAngular([Const, Ref] btVector3 angular);
	void addLinear([Const, Ref] btVector3 linear);
	//
	void setZero();
	//
	[Operator="+=", Ref] btSpatialForceVector op_add([Const, Ref] btSpatialForceVector vec);
	[Operator="-=", Ref] btSpatialForceVector op_sub([Const, Ref] btSpatialForceVector vec);
};

interface btSpatialMotionVector
{
	[Value] attribute btVector3 m_topVec;
  [Value] attribute btVector3 m_bottomVec;
	
	void btSpatialMotionVector();
	void btSpatialMotionVector([Const, Ref] btVector3 angular, [Const, Ref] btVector3 linear);
	
	void setVector([Const, Ref] btVector3 angular, [Const, Ref] btVector3 linear);
	// void setValue([Const, Ref] float ax, [Const, Ref] float ay, [Const, Ref] float az, [Const, Ref] float lx, [Const, Ref] float ly, [Const, Ref] float lz);
	void addVector([Const, Ref] btVector3 angular, [Const, Ref] btVector3 linear);
	// void addValue([Const, Ref] float ax, [Const, Ref] float ay, [Const, Ref] float az, [Const, Ref] float lx, [Const, Ref] float ly, [Const, Ref] float lz);
	
	[Const, Ref] btVector3 getAngular();
	[Const, Ref] btVector3 getLinear();
	
	void setAngular([Const, Ref] btVector3 angular);
	void setLinear([Const, Ref] btVector3 linear);
	
	void addAngular([Const, Ref] btVector3 angular);
	void addLinear([Const, Ref] btVector3 linear);
	
	void setZero();
	float dot([Const, Ref] btSpatialForceVector b);
	
	[Operator="+=", Ref] btSpatialMotionVector op_add([Const, Ref] btSpatialMotionVector vec);
  [Operator="-=", Ref] btSpatialMotionVector op_sub([Const, Ref] btSpatialMotionVector vec);
	// [Operator="*=", Ref] btSpatialMotionVector op_mul([Const, Ref] float s);
};

interface btSymmetricSpatialDyad {
	[Value] attribute btMatrix3x3 m_topLeftMat;
  [Value] attribute btMatrix3x3 m_topRightMat;
  [Value] attribute btMatrix3x3 m_bottomLeftMat;
	void btSymmetricSpatialDyad();
	void btSymmetricSpatialDyad([Const, Ref] btMatrix3x3 topLeftMat, [Const, Ref] btMatrix3x3 topRightMat, [Const, Ref] btMatrix3x3 bottomLeftMat);
	void setMatrix([Const, Ref] btMatrix3x3 topLeftMat, [Const, Ref] btMatrix3x3 topRightMat, [Const, Ref] btMatrix3x3 bottomLeftMat);
	void addMatrix([Const, Ref] btMatrix3x3 topLeftMat, [Const, Ref] btMatrix3x3 topRightMat, [Const, Ref] btMatrix3x3 bottomLeftMat);
	void setIdentity();
	[Operator="-=", Ref] btSymmetricSpatialDyad op_sub([Const, Ref] btSymmetricSpatialDyad mat);
};

// Collision

enum btCollisionObject_CollisionFlags {
  "btCollisionObject::CF_STATIC_OBJECT",
  "btCollisionObject::CF_KINEMATIC_OBJECT",
  "btCollisionObject::CF_NO_CONTACT_RESPONSE",
  "btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK",  //this allows per-triangle material (friction/restitution)
  "btCollisionObject::CF_CHARACTER_OBJECT",
  "btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT",          //disable debug drawing
  "btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING",  //disable parallel/SPU processing
};

enum btCollisionObject_CollisionObjectTypes {
  "btCollisionObject::CO_COLLISION_OBJECT",
  "btCollisionObject::CO_RIGID_BODY",
  "btCollisionObject::CO_GHOST_OBJECT",
  "btCollisionObject::CO_SOFT_BODY",
  "btCollisionObject::CO_HF_FLUID",
  "btCollisionObject::CO_USER_TYPE",
  "btCollisionObject::CO_FEATHERSTONE_LINK"
};

enum btCollisionObject_AnisotropicFrictionFlags {
  "btCollisionObject::CF_ANISOTROPIC_FRICTION_DISABLED",
  "btCollisionObject::CF_ANISOTROPIC_FRICTION",
  "btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION"
};

interface btCollisionObject {
  [Const, Ref] btVector3 getAnisotropicFriction();
  void setAnisotropicFriction([Const, Ref] btVector3 anisotropicFriction, long frictionMode);
  boolean hasAnisotropicFriction(optional long frictionMode);
  btCollisionShape getCollisionShape();
  float getContactProcessingThreshold();
  void setContactProcessingThreshold(float contactProcessingThreshold);
  long getActivationState();
  void setActivationState(long newState);
  void forceActivationState(long newState);
  void activate(optional boolean forceActivation);
  void setDeactivationTime(float time);
  float getDeactivationTime();
  boolean isActive();
  boolean isKinematicObject();
  boolean isStaticObject();
  boolean isStaticOrKinematicObject();
  [Const] float getRestitution();
  [Const] float getFriction();
  void setRestitution(float rest);
  void setFriction(float frict);
  void setRollingFriction(float frict);
  [Ref] btTransform getWorldTransform();
  long getCollisionFlags();
  void setCollisionFlags(long flags);
  void setWorldTransform([Const, Ref] btTransform worldTrans);
  void setCollisionShape(btCollisionShape collisionShape);
  void setCcdMotionThreshold (float ccdMotionThreshold);
  void setCcdSweptSphereRadius (float radius);
  long getUserIndex();
  void setUserIndex(long index);
  VoidPtr getUserPointer();
  void setUserPointer(VoidPtr userPointer);
  [Const] btBroadphaseProxy getBroadphaseHandle();
};

[NoDelete]
interface btCollisionObjectWrapper {
  [Const, Ref] btTransform getWorldTransform();
  [Const] btCollisionObject getCollisionObject();
  [Const] btCollisionShape getCollisionShape();
};

[Prefix="btCollisionWorld::"]
interface RayResultCallback {
  // abstract base class, no constructor
  boolean hasHit();
  attribute long m_collisionFilterGroup;
  attribute long m_collisionFilterMask;
  attribute float m_closestHitFraction;
  [Const] attribute btCollisionObject m_collisionObject;
  attribute unsigned long m_flags;
};

[Prefix="btCollisionWorld::"]
interface ClosestRayResultCallback {
  void ClosestRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);

  [Value] attribute btVector3 m_rayFromWorld;
  [Value] attribute btVector3 m_rayToWorld;
  [Value] attribute btVector3 m_hitNormalWorld;
  [Value] attribute btVector3 m_hitPointWorld;
};
ClosestRayResultCallback implements RayResultCallback;

interface btConstCollisionObjectArray {
  long size();
  [Const] btCollisionObject at(long n);
};

interface btScalarArray {
  long size();
  float at(long n);
};

[Prefix="btCollisionWorld::"]
interface AllHitsRayResultCallback {
  void AllHitsRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);

  [Value] attribute btConstCollisionObjectArray m_collisionObjects;
  [Value] attribute btVector3 m_rayFromWorld;
  [Value] attribute btVector3 m_rayToWorld;
  [Value] attribute btVector3Array m_hitNormalWorld;
  [Value] attribute btVector3Array m_hitPointWorld;
  [Value] attribute btScalarArray m_hitFractions;
};
AllHitsRayResultCallback implements RayResultCallback;

interface btManifoldPoint {
  [Const, Ref] btVector3 getPositionWorldOnA();
  [Const, Ref] btVector3 getPositionWorldOnB();
  [Const] double getAppliedImpulse();
  [Const] double getDistance();
  [Value] attribute btVector3 m_localPointA;
  [Value] attribute btVector3 m_localPointB;
  [Value] attribute btVector3 m_positionWorldOnB;
  [Value] attribute btVector3 m_positionWorldOnA;
  [Value] attribute btVector3 m_normalWorldOnB;

  // Contact callback support
  attribute any m_userPersistentData;
};

[Prefix="btCollisionWorld::"]
interface ContactResultCallback {
  float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
};

[JSImplementation="ContactResultCallback"]
interface ConcreteContactResultCallback {
  void ConcreteContactResultCallback();
  float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
};

[Prefix="btCollisionWorld::"]
interface LocalShapeInfo {
    attribute long m_shapePart;
    attribute long m_triangleIndex;
 };

[Prefix="btCollisionWorld::"]
interface LocalConvexResult  {
  void LocalConvexResult([Const] btCollisionObject hitCollisionObject, LocalShapeInfo localShapeInfo, [Const, Ref] btVector3 hitNormalLocal, [Const, Ref] btVector3 hitPointLocal, float hitFraction);
  [Const] attribute btCollisionObject m_hitCollisionObject;
  attribute LocalShapeInfo m_localShapeInfo;
  [Value] attribute btVector3 m_hitNormalLocal;
  [Value] attribute btVector3 m_hitPointLocal;
  attribute float m_hitFraction;
};

[Prefix="btCollisionWorld::"]
interface ConvexResultCallback {
  // abstract base class, no constructor
  boolean hasHit();
  attribute short m_collisionFilterGroup;
  attribute short m_collisionFilterMask;
  attribute float m_closestHitFraction;
};

[Prefix="btCollisionWorld::"]
interface ClosestConvexResultCallback {
  void ClosestConvexResultCallback([Const, Ref] btVector3 convexFromWorld, [Const, Ref] btVector3 convexToWorld);
  [Const] attribute btCollisionObject m_hitCollisionObject;
  [Value] attribute btVector3 m_convexFromWorld;
  [Value] attribute btVector3 m_convexToWorld;
  [Value] attribute btVector3 m_hitNormalWorld;
  [Value] attribute btVector3 m_hitPointWorld;
};
ClosestConvexResultCallback implements ConvexResultCallback;

interface btCollisionShape {
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const, Ref] btVector3 getLocalScaling();
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  void setMargin(float margin);
  float getMargin();
};

interface btConvexShape {
};
btConvexShape implements btCollisionShape;

interface btConvexTriangleMeshShape {
  void btConvexTriangleMeshShape(btStridingMeshInterface meshInterface, optional boolean calcAabb);
};
btConvexTriangleMeshShape implements btConvexShape;

interface btBoxShape {
  void btBoxShape([Ref] btVector3 boxHalfExtents);
  void setMargin(float margin);
  float getMargin();
};
btBoxShape implements btCollisionShape;

interface btCapsuleShape {
  void btCapsuleShape(float radius, float height);
  void setMargin(float margin);
  float getMargin();
  long getUpAxis();
  float getRadius();
  float getHalfHeight();
};
btCapsuleShape implements btCollisionShape;

interface btCapsuleShapeX {
  void btCapsuleShapeX(float radius, float height);
  void setMargin(float margin);
  float getMargin();
};
btCapsuleShapeX implements btCapsuleShape;

interface btCapsuleShapeZ {
  void btCapsuleShapeZ(float radius, float height);
  void setMargin(float margin);
  float getMargin();
};
btCapsuleShapeZ implements btCapsuleShape;

interface btCylinderShape {
  void btCylinderShape([Ref] btVector3 halfExtents);
  void setMargin(float margin);
  float getMargin();
};
btCylinderShape implements btCollisionShape;

interface btCylinderShapeX {
  void btCylinderShapeX([Ref] btVector3 halfExtents);
  void setMargin(float margin);
  float getMargin();
};
btCylinderShapeX implements btCylinderShape;

interface btCylinderShapeZ {
  void btCylinderShapeZ([Ref] btVector3 halfExtents);
  void setMargin(float margin);
  float getMargin();
};
btCylinderShapeZ implements btCylinderShape;

interface btSphereShape {
  void btSphereShape(float radius);
  void setMargin(float margin);
  float getMargin();
};
btSphereShape implements btCollisionShape;

interface btMultiSphereShape {
  void btMultiSphereShape([Const] btVector3 positions, [Const] float[] radii, long numPoints);
};
btMultiSphereShape implements btCollisionShape;

interface btConeShape {
  void btConeShape(float radius, float height);
};
btConeShape implements btCollisionShape;

interface btConeShapeX {
  void btConeShapeX(float radius, float height);
};
btConeShapeX implements btConeShape;

interface btConeShapeZ {
  void btConeShapeZ(float radius, float height);
};
btConeShapeZ implements btConeShape;

interface btIntArray {
  long size();
  long at(long n);
};

interface btFace {
  [Value] attribute btIntArray m_indices;
  attribute float[] m_plane;
};

interface btVector3Array {
  void btVector3Array();
  long size();
  [Const, Ref] btVector3 at(long n);
  void clear();
  void pop_back();
  void resize(long newsize, [Const, Ref] btVector3? fillData);
  [Ref] btVector3 expandNonInitializing();
  [Ref] btVector3 expand([Const, Ref] btVector3? fillValue);
  void push_back([Const, Ref] btVector3 _Val);
  long capacity();
  void reserve(long _Count);
};

interface btQuaternionArray {
  void btQuaternionArray();
  long size();
  [Const, Ref] btQuaternion at(long n);
  void clear();
  void pop_back();
  void resize(long newsize, [Const, Ref] btQuaternion? fillData);
  [Ref] btQuaternion expandNonInitializing();
  [Ref] btQuaternion expand([Const, Ref] btQuaternion? fillValue);
  void push_back([Const, Ref] btQuaternion _Val);
  long capacity();
  void reserve(long _Count);
};

interface btMatrix3x3Array {
  void btMatrix3x3Array();
  long size();
  [Const, Ref] btMatrix3x3 at(long n);
  void clear();
  void pop_back();
  void resize(long newsize, [Const, Ref] btMatrix3x3? fillData);
  [Ref] btMatrix3x3 expandNonInitializing();
  [Ref] btMatrix3x3 expand([Const, Ref] btMatrix3x3? fillValue);
  void push_back([Const, Ref] btMatrix3x3 _Val);
  long capacity();
  void reserve(long _Count);
};

interface btFaceArray {
  void btFaceArray();
  long size();
  [Const, Ref] btFace at(long n);
  void clear();
  void pop_back();
  void resize(long newsize, [Const, Ref] btFace? fillData);
  [Ref] btFace expandNonInitializing();
  [Ref] btFace expand([Const, Ref] btFace? fillValue);
  void push_back([Const, Ref] btFace _Val);
  long capacity();
  void reserve(long _Count);
};

interface btConvexPolyhedron {
  [Value] attribute btVector3Array m_vertices;
  [Value] attribute btFaceArray m_faces;
};

interface btConvexHullShape {
  void btConvexHullShape([Const] optional float[] points, optional long numPoints);
  void addPoint([Const, Ref] btVector3 point, optional boolean recalculateLocalAABB);
  void setMargin(float margin);
  float getMargin();
  long getNumVertices();
  boolean initializePolyhedralFeatures(long shiftVerticesByMargin);
  void recalcLocalAabb();
  [Const] btConvexPolyhedron getConvexPolyhedron();
};
btConvexHullShape implements btCollisionShape;

interface btShapeHull {
  void btShapeHull(btConvexShape shape);
  boolean buildHull(float margin);
  long numVertices();
  [Const] btVector3 getVertexPointer();
};

interface btCompoundShape {
  void btCompoundShape(optional boolean enableDynamicAabbTree);
  void addChildShape([Const, Ref] btTransform localTransform, btCollisionShape shape);
  void removeChildShape(btCollisionShape shape);
  void removeChildShapeByIndex(long childShapeindex);
  [Const] long getNumChildShapes();
  btCollisionShape getChildShape(long index);
  void updateChildTransform(long childIndex, [Const, Ref] btTransform newChildTransform, optional boolean shouldRecalculateLocalAabb);
  void setMargin(float margin);
  float getMargin();
};
btCompoundShape implements btCollisionShape;

interface btStridingMeshInterface {
  void setScaling([Const, Ref] btVector3 scaling);
};

interface btIndexedMesh {
  attribute long m_numTriangles;
};

interface btIndexedMeshArray {
  long size();
  [Const, Ref] btIndexedMesh at(long n);
};

interface btTriangleMesh {
  void btTriangleMesh(optional boolean use32bitIndices, optional boolean use4componentVertices);
  void addTriangle([Const, Ref] btVector3 vertex0, [Const, Ref] btVector3 vertex1, [Const, Ref] btVector3 vertex2, optional boolean removeDuplicateVertices);
  void addTriangleIndices(long index1, long index2, long index3);
  long findOrAddVertex([Const, Ref] btVector3 vertex, boolean removeDuplicateVertices);
  void addIndex(long index);
 [Ref] btIndexedMeshArray getIndexedMeshArray();
};
btTriangleMesh implements btStridingMeshInterface;

enum PHY_ScalarType {
    "PHY_FLOAT",
    "PHY_DOUBLE",
    "PHY_INTEGER",
    "PHY_SHORT",
    "PHY_FIXEDPOINT88",
    "PHY_UCHAR"
};

interface btTriangleCallback {
	void processTriangle(btVector3 triangle, long partId, long triangleIndex);
};

[JSImplementation="btTriangleCallback"]
interface btTriangleCallback_implJS {
	void processTriangle(btVector3 triangle, long partId, long triangleIndex);
};

interface btConcaveShape {
};
btConcaveShape implements btCollisionShape;

interface btEmptyShape {
  void btEmptyShape();
};
btEmptyShape implements btConcaveShape;

interface btStaticPlaneShape {
  void btStaticPlaneShape([Const, Ref] btVector3 planeNormal, float planeConstant);
};
btStaticPlaneShape implements btConcaveShape;

interface btTriangleMeshShape {
};
btTriangleMeshShape implements btConcaveShape;

interface btBvhTriangleMeshShape {
  void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, optional boolean buildBvh);
  
  void performRaycast(btTriangleCallback callback, [Const, Ref] btVector3 raySource, [Const, Ref] btVector3 rayTarget);
};
btBvhTriangleMeshShape implements btTriangleMeshShape;

interface btHeightfieldTerrainShape {
    void btHeightfieldTerrainShape(long heightStickWidth, long heightStickLength, VoidPtr heightfieldData, float heightScale, float minHeight, float maxHeight, long upAxis, PHY_ScalarType hdt, boolean flipQuadEdges);
    void setMargin(float margin);
    float getMargin();
};
btHeightfieldTerrainShape implements btConcaveShape;

// GImpact

interface btAABB {
  void btAABB([ Const, Ref ] btVector3 V1, [ Const, Ref ] btVector3 V2, [ Const, Ref ] btVector3 V3, float margin);
  void invalidate();
  void increment_margin(float margin);
  void copy_with_margin([ Const, Ref ] btAABB other, float margin);
};

interface btPrimitiveTriangle {
  void btPrimitiveTriangle();
};

interface btTriangleShapeEx {
  void btTriangleShapeEx([ Const, Ref ] btVector3 p1, [ Const, Ref ] btVector3 p2, [ Const, Ref ] btVector3 p3);
  void getAabb([ Const, Ref ] btTransform t, [ Ref ] btVector3 aabbMin, [ Ref ] btVector3 aabbMax);
  void applyTransform([ Const, Ref ] btTransform t);
  // void buildTriPlane([ Ref ] btVector4 plane);
};

interface btPrimitiveManagerBase {
  boolean is_trimesh();
  long get_primitive_count();
  void get_primitive_box(long prim_index , [Ref] btAABB primbox);
  void get_primitive_triangle(long prim_index, [Ref] btPrimitiveTriangle triangle);
};

enum eGIMPACT_SHAPE_TYPE {
	"CONST_GIMPACT_COMPOUND_SHAPE",
	"CONST_GIMPACT_TRIMESH_SHAPE_PART",
	"CONST_GIMPACT_TRIMESH_SHAPE"
};

interface btTetrahedronShapeEx {
    void btTetrahedronShapeEx();
    void setVertices([ Const, Ref ] btVector3 v0, [ Const, Ref ] btVector3 v1, [ Const, Ref ] btVector3 v2, [ Const, Ref ] btVector3 v3);
};

interface btGImpactShapeInterface {
  void updateBound();
  void postUpdate();
  long getShapeType();
  [Const] DOMString getName();
  eGIMPACT_SHAPE_TYPE getGImpactShapeType();
  [Const] btPrimitiveManagerBase getPrimitiveManager();
  long getNumChildShapes();
  boolean childrenHasTransform();
  boolean needsRetrieveTriangles();
  boolean needsRetrieveTetrahedrons();
  void getBulletTriangle(long prim_index, [Ref] btTriangleShapeEx triangle);
  void getBulletTetrahedron(long prim_index, [Ref] btTetrahedronShapeEx tetrahedron);
  [Const] btCollisionShape getChildShape(long index);
  [Value] btTransform getChildTransform(long index);
  void setChildTransform(long index, [Const, Ref] btTransform transform);
};
btGImpactShapeInterface implements btConcaveShape;

[Prefix="btGImpactCompoundShape::"]
interface CompoundPrimitiveManager {
  attribute btGImpactCompoundShape m_compoundShape;
  long get_primitive_count();
  void get_primitive_box(long prim_index, [Ref] btAABB primbox);
  void get_primitive_triangle(long prim_index, [Ref] btPrimitiveTriangle triangle);
};
CompoundPrimitiveManager implements btPrimitiveManagerBase;

interface btGImpactCompoundShape {
  void btGImpactCompoundShape(optional boolean children_has_transform = true);
  boolean childrenHasTransform();
  [Const] btPrimitiveManagerBase getPrimitiveManager();
  CompoundPrimitiveManager getCompoundPrimitiveManager();
  long getNumChildShapes();
  void addChildShape([ Const, Ref ] btTransform localTransform, btCollisionShape shape);
  btCollisionShape getChildShape(long index);
  void getChildAabb(long child_index, [ Const, Ref ] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  [Value] btTransform	getChildTransform(long index);
  void setChildTransform(long index, [ Const, Ref ] btTransform transform);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  [Const] DOMString getName();
  eGIMPACT_SHAPE_TYPE getGImpactShapeType();
};
btGImpactCompoundShape implements btGImpactShapeInterface;

[Prefix = "btGImpactMeshShapePart::"]
interface TrimeshPrimitiveManager {
  attribute float m_margin;
  attribute btStridingMeshInterface m_meshInterface;
  attribute long m_part;
  attribute long m_lock_count;
  attribute long numverts;
  attribute PHY_ScalarType type;
  attribute long stride;
  attribute long indexstride;
  attribute long numfaces;
  attribute PHY_ScalarType indicestype;
  void TrimeshPrimitiveManager([Const, Ref] optional TrimeshPrimitiveManager manager);
  void lock();
  void unlock();
  boolean is_trimesh();
  long get_vertex_count();
  void get_indices(long face_index, unsigned long i0, unsigned long i1, unsigned long i2);
  void get_vertex(unsigned long vertex_index, [Ref] btVector3 vertex);
  void get_bullet_triangle(long prim_index, [Ref] btTriangleShapeEx triangle);
};
TrimeshPrimitiveManager implements btPrimitiveManagerBase;

interface btGImpactMeshShapePart {
  void btGImpactMeshShapePart(btStridingMeshInterface meshInterface, long part);
  TrimeshPrimitiveManager getTrimeshPrimitiveManager();
  long getVertexCount();
  void getVertex(long vertex_index, [Ref] btVector3 vertex);
  long getPart();
};
btGImpactMeshShapePart implements btGImpactShapeInterface;

interface btGImpactMeshShape {
  void btGImpactMeshShape(btStridingMeshInterface meshInterface);
  [Const] btStridingMeshInterface getMeshInterface();
  long getMeshPartCount();
  [Const] btGImpactMeshShapePart getMeshPart(long index);
  long calculateSerializeBufferSize();
};
btGImpactMeshShape implements btGImpactShapeInterface;

interface btCollisionAlgorithmConstructionInfo {
	void btCollisionAlgorithmConstructionInfo();
	void btCollisionAlgorithmConstructionInfo(btDispatcher dispatcher, long temp);
	attribute btDispatcher m_dispatcher1;
	attribute btPersistentManifold m_manifold;
};

interface btCollisionAlgorithm {
};

interface btActivatingCollisionAlgorithm {
};
btActivatingCollisionAlgorithm implements btCollisionAlgorithm;

interface btGImpactCollisionAlgorithm {
  void btGImpactCollisionAlgorithm([Const, Ref] btCollisionAlgorithmConstructionInfo ci, [Const] btCollisionObjectWrapper body0Wrap, [Const] btCollisionObjectWrapper body1Wrap);
  static void registerAlgorithm(btCollisionDispatcher dispatcher);
};
btGImpactCollisionAlgorithm implements btActivatingCollisionAlgorithm;

//

interface btDefaultCollisionConstructionInfo {
  void btDefaultCollisionConstructionInfo();
};

interface btDefaultCollisionConfiguration {
  void btDefaultCollisionConfiguration([Ref] optional btDefaultCollisionConstructionInfo info);
};

interface btPersistentManifold {
  void btPersistentManifold();
  [Const] btCollisionObject getBody0();
  [Const] btCollisionObject getBody1();
  long getNumContacts();
  [Ref] btManifoldPoint getContactPoint(long index);
};

interface btDispatcher {
  long getNumManifolds();
  btPersistentManifold getManifoldByIndexInternal(long index);
};

interface btCollisionDispatcher {
  void btCollisionDispatcher(btDefaultCollisionConfiguration conf);
};
btCollisionDispatcher implements btDispatcher;

interface btOverlappingPairCallback {
};

interface btOverlappingPairCache {
  void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);
  [Const] float getNumOverlappingPairs();
};

interface btAxisSweep3 {
  void btAxisSweep3([Ref] btVector3 worldAabbMin, [Ref] btVector3 worldAabbMax, optional long maxHandles, optional btOverlappingPairCache pairCache, optional boolean disableRaycastAccelerator);
};

interface btBroadphaseInterface {
  btOverlappingPairCache getOverlappingPairCache();
};

interface btCollisionConfiguration {
};

interface btDbvtBroadphase {
  void btDbvtBroadphase();
};

interface btBroadphaseProxy {
  attribute long m_collisionFilterGroup;
  attribute long m_collisionFilterMask;
};


// Dynamics

[Prefix="btRigidBody::"]
interface btRigidBodyConstructionInfo {
  void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [Ref] optional btVector3 localInertia);
  attribute float m_linearDamping;
  attribute float m_angularDamping;
  attribute float m_friction;
  attribute float m_rollingFriction;
  attribute float m_restitution;
  attribute float m_linearSleepingThreshold;
  attribute float m_angularSleepingThreshold;
  attribute boolean m_additionalDamping;
  attribute float m_additionalDampingFactor;
  attribute float m_additionalLinearDampingThresholdSqr;
  attribute float m_additionalAngularDampingThresholdSqr;
  attribute float m_additionalAngularDampingFactor;
};

interface btRigidBody {
  void btRigidBody([Const, Ref] btRigidBodyConstructionInfo constructionInfo);
  
  [Const, Ref] btTransform getCenterOfMassTransform();
  void setCenterOfMassTransform([Const, Ref] btTransform xform);
  void setSleepingThresholds(float linear, float angular);
	float getLinearSleepingThreshold();
	float getAngularSleepingThreshold();
  [Const] float getLinearDamping();
  [Const] float getAngularDamping();
  void setDamping(float lin_damping, float ang_damping);
  void applyDamping(float timeStep);
  void setMassProps(float mass, [Const, Ref] btVector3 inertia);
	float getInvMass();
  [Const, Ref] btVector3 getLinearFactor();
  void setLinearFactor([Const, Ref] btVector3 linearFactor);
  void applyTorque([Const, Ref] btVector3 torque);
  // void applyLocalTorque([Const, Ref] btVector3 torque);
  void applyForce([Const, Ref] btVector3 force, [Const, Ref] btVector3 rel_pos);
  // void applyCentralForce([Const, Ref] btVector3 force);
  // void applyCentralLocalForce([Const, Ref] btVector3 force);
  void applyCentralImpulse([Const, Ref] btVector3 impulse);
  void applyTorqueImpulse([Const, Ref] btVector3 torque);
  void applyImpulse([Const, Ref] btVector3 impulse, [Const, Ref] btVector3 rel_pos);
  [Const, Ref] btVector3 getCenterOfMassPosition();
  [Value] btQuaternion getOrientation();
	[Const, Ref] btVector3 getTotalForce();
	[Const, Ref] btVector3 getTotalTorque();
	[Const, Ref] btVector3 getInvInertiaDiagLocal();
	void setInvInertiaDiagLocal([Const, Ref] btVector3 diagInvInertia);
  void updateInertiaTensor();
  [Const, Ref] btVector3 getLinearVelocity();
  [Const, Ref] btVector3 getAngularVelocity();
  void setLinearVelocity([Const, Ref] btVector3 lin_vel);
  void setAngularVelocity([Const, Ref] btVector3 ang_vel);
  [Value] btVector3 getVelocityInLocalPoint([Const, Ref] btVector3 rel_pos);
  void translate([Const, Ref] btVector3 v);
  btMotionState getMotionState();
  void setMotionState(btMotionState motionState);
  [Const, Ref] btVector3 getAngularFactor();
  void setAngularFactor([Const, Ref] btVector3 angularFactor);
  btRigidBody upcast(btCollisionObject colObj);
  void getAabb([Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void applyGravity();
  [Const, Ref] btVector3 getGravity();
  void setGravity([Const, Ref] btVector3 acceleration);
  [Const] btBroadphaseProxy getBroadphaseProxy();
  void clearForces();
  void setFlags(long flags);
  [Const] long getFlags();
};
btRigidBody implements btCollisionObject;

interface btSolverBody {
	[Value] attribute btTransform		m_worldTransform;
	[Value] attribute btVector3		m_deltaLinearVelocity;
	[Value] attribute btVector3		m_deltaAngularVelocity;
	[Value] attribute btVector3		m_angularFactor;
	[Value] attribute btVector3		m_linearFactor;
	[Value] attribute btVector3		m_invMass;
	[Value] attribute btVector3		m_pushVelocity;
	[Value] attribute btVector3		m_turnVelocity;
	[Value] attribute btVector3		m_linearVelocity;
	[Value] attribute btVector3		m_angularVelocity;
	[Value] attribute btVector3		m_externalForceImpulse;
	[Value] attribute btVector3		m_externalTorqueImpulse;
	attribute btRigidBody	        m_originalBody;
	void	setWorldTransform([Const, Ref] btTransform worldTransform);
	[Const, Ref] btTransform getWorldTransform();
	void getVelocityInLocalPointNoDelta([Const, Ref] btVector3 rel_pos, [Ref] btVector3 velocity);
	void getVelocityInLocalPointObsolete([Const, Ref] btVector3 rel_pos, [Ref] btVector3 velocity);
	void getAngularVelocity([Ref] btVector3 angVel);
	//Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
	void applyImpulse([Const, Ref] btVector3 linearComponent, [Const, Ref] btVector3 angularComponent, [Const] float impulseMagnitude);
	void internalApplyPushImpulse([Const, Ref] btVector3 linearComponent, [Const, Ref] btVector3 angularComponent, float impulseMagnitude);
	[Const, Ref] btVector3 getDeltaLinearVelocity();
	[Const, Ref] btVector3 getDeltaAngularVelocity();
	[Const, Ref] btVector3 getPushVelocity();
	[Const, Ref] btVector3 getTurnVelocity();
};

interface btSolverBodyArray {
  long size();
  [Const, Ref] btSolverBody at(long n);
};

interface btConstraintSetting {
  void btConstraintSetting();
  attribute float m_tau;
  attribute float m_damping;
  attribute float m_impulseClamp;
};

interface btJointFeedback {
	[Value] attribute btVector3 m_appliedForceBodyA;
	[Value] attribute btVector3 m_appliedTorqueBodyA;
	[Value] attribute btVector3 m_appliedForceBodyB;
	[Value] attribute btVector3 m_appliedTorqueBodyB;
};

interface btTypedConstraint {
	long getOverrideNumSolverIterations();
	///override the number of constraint solver iterations used to solve this constraint
	///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
	void setOverrideNumSolverIterations(long overideNumIterations);
  
  void enableFeedback(boolean needsFeedback);
	boolean needsFeedback();

	void setJointFeedback(btJointFeedback jointFeedback);
	[Const] btJointFeedback getJointFeedback();

	///getAppliedImpulse is an estimated total applied impulse. 
	///This feedback could be used to determine breaking constraints or playing sounds.
	float getAppliedImpulse();

	btTypedConstraintType getConstraintType();

  [Const] float getBreakingImpulseThreshold();
  void setBreakingImpulseThreshold([Const] float threshold);
  [Const] float getParam(long num, long axis);
  void setParam(long num, float value, long axis);

	boolean isEnabled();
	void setEnabled(boolean enabled);


	[Const, Ref] btRigidBody getRigidBodyA();
	[Const, Ref] btRigidBody getRigidBodyB();

	long getUserConstraintType();
	void setUserConstraintType(long userConstraintType);

	[Ref] static btRigidBody getFixedBody();
};

enum btTypedConstraintType {
	"POINT2POINT_CONSTRAINT_TYPE",
	"HINGE_CONSTRAINT_TYPE",
	"CONETWIST_CONSTRAINT_TYPE",
	"D6_CONSTRAINT_TYPE",
	"SLIDER_CONSTRAINT_TYPE",
	"CONTACT_CONSTRAINT_TYPE",
	"D6_SPRING_CONSTRAINT_TYPE",
	"GEAR_CONSTRAINT_TYPE",
	"FIXED_CONSTRAINT_TYPE",
	"MAX_CONSTRAINT_TYPE"
};

enum btConstraintParams {
  "BT_CONSTRAINT_ERP",
  "BT_CONSTRAINT_STOP_ERP",
  "BT_CONSTRAINT_CFM",
  "BT_CONSTRAINT_STOP_CFM"
};

interface btPoint2PointConstraint {
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btVector3 pivotInA, [Ref] btVector3 pivotInB);
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btVector3 pivotInA);
  void setPivotA([Const, Ref] btVector3 pivotA);
  void setPivotB([Const, Ref] btVector3 pivotB);
  [Const, Ref] btVector3 getPivotInA();
  [Const, Ref] btVector3 getPivotInB();

  [Value] attribute btConstraintSetting m_setting;
};
btPoint2PointConstraint implements btTypedConstraint;

interface btGeneric6DofConstraint {
  void btGeneric6DofConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform frameInA, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameA);
  void btGeneric6DofConstraint([Ref] btRigidBody rbB, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameB);
  void setLinearLowerLimit([Const, Ref] btVector3 linearLower);
  void setLinearUpperLimit([Const, Ref] btVector3 linearUpper);
  void setAngularLowerLimit([Const, Ref] btVector3 angularLower);
  void setAngularUpperLimit([Const, Ref] btVector3 angularUpper);
  [Const, Ref] btTransform getFrameOffsetA();
};
btGeneric6DofConstraint implements btTypedConstraint;

interface btGeneric6DofSpringConstraint {
  void btGeneric6DofSpringConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform frameInA, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameA);
  void btGeneric6DofSpringConstraint([Ref] btRigidBody rbB, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameB);
  void enableSpring(long index, boolean onOff);
  void setStiffness(long index, float stiffness);
  void setDamping(long index, float damping);
  void setEquilibriumPoint(long index, float val);
  void setEquilibriumPoint(long index);
  void setEquilibriumPoint();
};
btGeneric6DofSpringConstraint implements btGeneric6DofConstraint;

interface btSequentialImpulseConstraintSolver {
  void btSequentialImpulseConstraintSolver();
};

interface btConeTwistConstraint {
  void btConeTwistConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform rbAFrame, [Ref] btTransform rbBFrame);
  void btConeTwistConstraint([Ref] btRigidBody rbA, [Ref] btTransform rbAFrame);

  void setLimit(long limitIndex, float limitValue);
  void setAngularOnly(boolean angularOnly);
  void setDamping(float damping);
  void enableMotor(boolean b);
  void setMaxMotorImpulse(float maxMotorImpulse);
  void setMaxMotorImpulseNormalized(float maxMotorImpulse);
  void setMotorTarget([Const,Ref] btQuaternion q);
  void setMotorTargetInConstraintSpace([Const,Ref] btQuaternion q);
};
btConeTwistConstraint implements btTypedConstraint;

interface btHingeConstraint {
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btVector3 pivotInA, [Ref] btVector3 pivotInB, [Ref] btVector3 axisInA, [Ref] btVector3 axisInB, optional boolean useReferenceFrameA);
  //void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btVector3 pivotInA, [Ref] btVector3 axisInA, optional boolean useReferenceFrameA);
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform rbAFrame, [Ref] btTransform rbBFrame, optional boolean useReferenceFrameA);
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btTransform rbAFrame, optional boolean useReferenceFrameA);

  float getHingeAngle();

  void setLimit(float low, float high, float softness, float biasFactor, optional float relaxationFactor);
  void enableAngularMotor(boolean enableMotor, float targetVelocity, float maxMotorImpulse);
  void setAngularOnly(boolean angularOnly);

  void enableMotor(boolean enableMotor);
  void setMaxMotorImpulse(float maxMotorImpulse);
  //void setMotorTarget([Const,Ref] btQuaternion qAinB, float dt);
  void setMotorTarget(float targetAngle, float dt);
};
btHingeConstraint implements btTypedConstraint;

interface btSliderConstraint {
  void btSliderConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const,Ref] btTransform frameInA, [Const,Ref] btTransform frameInB, boolean useLinearReferenceFrameA);
  void btSliderConstraint([Ref] btRigidBody rbB, [Const,Ref] btTransform frameInB, boolean useLinearReferenceFrameA);

  [Const] float getLinearPos();
  [Const] float getAngularPos();

  void setLowerLinLimit(float lowerLimit);
  void setUpperLinLimit(float upperLimit);
  void setLowerAngLimit(float lowerAngLimit);
  void setUpperAngLimit(float upperAngLimit);

  void setPoweredLinMotor(boolean onOff);
  void setMaxLinMotorForce(float maxLinMotorForce);
  void setTargetLinMotorVelocity(float targetLinMotorVelocity);
};
btSliderConstraint implements btTypedConstraint;

interface btFixedConstraint {
  void btFixedConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const,Ref] btTransform frameInA, [Const,Ref] btTransform frameInB);
};
btFixedConstraint implements btTypedConstraint;

enum btConstraintSolverType {
	"BT_SEQUENTIAL_IMPULSE_SOLVER",
	"BT_MLCP_SOLVER"
};

interface btConstraintSolver {
};

interface btDispatcherInfo {
  attribute float m_timeStep;
  attribute long m_stepCount;
  attribute long m_dispatchFunc;
  attribute float m_timeOfImpact;
  attribute boolean m_useContinuous;
  attribute boolean m_enableSatConvex;
  attribute boolean m_enableSPU;
  attribute boolean m_useEpa;
  attribute float m_allowedCcdPenetration;
  attribute boolean m_useConvexConservativeDistanceUtil;
  attribute float m_convexConservativeDistanceThreshold;
};

interface btCollisionWorld {
  btDispatcher getDispatcher();
  void rayTest([Const, Ref] btVector3 rayFromWorld, [Const, Ref] btVector3 rayToWorld, [Ref] RayResultCallback resultCallback);
  btOverlappingPairCache getPairCache();
  [Ref] btDispatcherInfo getDispatchInfo();
  void addCollisionObject(btCollisionObject collisionObject, optional short collisionFilterGroup, optional short collisionFilterMask);
  void removeCollisionObject(btCollisionObject collisionObject);
  [Const] btBroadphaseInterface getBroadphase ();
  void convexSweepTest([Const] btConvexShape castShape, [Const, Ref] btTransform from, [Const, Ref] btTransform to, [Ref] ConvexResultCallback resultCallback, float allowedCcdPenetration);
  void contactPairTest(btCollisionObject colObjA, btCollisionObject colObjB, [Ref] ContactResultCallback resultCallback);
  void contactTest(btCollisionObject colObj, [Ref] ContactResultCallback resultCallback);
  void updateSingleAabb(btCollisionObject colObj);
  void setDebugDrawer(btIDebugDraw debugDrawer);
  btIDebugDraw getDebugDrawer();
  void debugDrawWorld();
  void debugDrawObject([Const, Ref] btTransform worldTransform, [Const] btCollisionShape shape, [Const, Ref] btVector3 color);
};

interface btContactSolverInfo {
  attribute boolean m_splitImpulse;
  attribute long m_splitImpulsePenetrationThreshold;
  attribute long m_numIterations;
};

interface btDynamicsWorld {
  void addAction(btActionInterface action);
  void removeAction(btActionInterface action);
  [Ref] btContactSolverInfo getSolverInfo();
  //https://emscripten.org/docs/porting/guidelines/function_pointer_issues.html
  // void setInternalTickCallback(VoidPtr cb, optional VoidPtr worldUserInfo, optional boolean isPreTick);
};
btDynamicsWorld implements btCollisionWorld;

interface btDiscreteDynamicsWorld {
  void btDiscreteDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);

  void setGravity([Ref] btVector3 gravity);
  [Value] btVector3 getGravity();

  void addRigidBody(btRigidBody body);
  void addRigidBody(btRigidBody body, short group, short mask);
  void removeRigidBody(btRigidBody body);

  void addConstraint(btTypedConstraint constraint, optional boolean disableCollisionsBetweenLinkedBodies);
  void removeConstraint(btTypedConstraint constraint);

  long stepSimulation(float timeStep, optional long maxSubSteps, optional float fixedTimeStep);
};
btDiscreteDynamicsWorld implements btDynamicsWorld;

[Prefix="btRaycastVehicle::", NoDelete]
interface btVehicleTuning {
  void btVehicleTuning();
  attribute float m_suspensionStiffness;
  attribute float m_suspensionCompression;
  attribute float m_suspensionDamping;
  attribute float m_maxSuspensionTravelCm;
  attribute float m_frictionSlip;
  attribute float m_maxSuspensionForce;
};

[Prefix="btDefaultVehicleRaycaster::"]
interface btVehicleRaycasterResult {
    [Value] attribute btVector3 m_hitPointInWorld;
    [Value] attribute btVector3 m_hitNormalInWorld;
    attribute float m_distFraction;
};

interface btVehicleRaycaster {
    void castRay ([Const, Ref] btVector3 from, [Const, Ref] btVector3 to, [Ref] btVehicleRaycasterResult result);
};

interface btDefaultVehicleRaycaster {
  void btDefaultVehicleRaycaster(btDynamicsWorld world);
};
btDefaultVehicleRaycaster implements btVehicleRaycaster;

[Prefix="btWheelInfo::"]
interface RaycastInfo {
  [Value] attribute btVector3 m_contactNormalWS;
  [Value] attribute btVector3 m_contactPointWS;
  attribute float m_suspensionLength;
  [Value] attribute btVector3 m_hardPointWS;
  [Value] attribute btVector3 m_wheelDirectionWS;
  [Value] attribute btVector3 m_wheelAxleWS;
  attribute boolean m_isInContact;
  attribute any m_groundObject;
};

interface btWheelInfoConstructionInfo {
    [Value] attribute btVector3 m_chassisConnectionCS;
    [Value] attribute btVector3 m_wheelDirectionCS;
    [Value] attribute btVector3 m_wheelAxleCS;
    attribute float m_suspensionRestLength;
    attribute float m_maxSuspensionTravelCm;
    attribute float m_wheelRadius;
    attribute float m_suspensionStiffness;
    attribute float m_wheelsDampingCompression;
    attribute float m_wheelsDampingRelaxation;
    attribute float m_frictionSlip;
    attribute float m_maxSuspensionForce;
    attribute boolean m_bIsFrontWheel;
};

interface btWheelInfo {
  attribute float m_suspensionStiffness;
  attribute float m_frictionSlip;
  attribute float m_engineForce;
  attribute float m_rollInfluence;
  attribute float m_suspensionRestLength1;
  attribute float m_wheelsRadius;
  attribute float m_wheelsDampingCompression;
  attribute float m_wheelsDampingRelaxation;
  attribute float m_steering;
  attribute float m_maxSuspensionForce;
  attribute float m_maxSuspensionTravelCm;
  attribute float m_wheelsSuspensionForce;
  attribute boolean m_bIsFrontWheel;
  [Value] attribute RaycastInfo m_raycastInfo;
  [Value] attribute btVector3 m_chassisConnectionPointCS;
  void btWheelInfo([Ref] btWheelInfoConstructionInfo ci);
  float getSuspensionRestLength ();
  void  updateWheel ([Const, Ref] btRigidBody chassis, [Ref] RaycastInfo raycastInfo);
  [Value] attribute btTransform m_worldTransform;
  [Value] attribute btVector3 m_wheelDirectionCS;
  [Value] attribute btVector3 m_wheelAxleCS;
  attribute float m_rotation;
  attribute float m_deltaRotation;
  attribute float m_brake;
  attribute float  m_clippedInvContactDotSuspension;
  attribute float  m_suspensionRelativeVelocity;
  attribute float  m_skidInfo;
};

interface btActionInterface {
    void updateAction (btCollisionWorld collisionWorld, float deltaTimeStep);
};

interface btRaycastVehicle {
  void btRaycastVehicle([Const, Ref] btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster);
  void applyEngineForce(float force, long wheel);
  void setSteeringValue(float steering, long wheel);
  [Const, Ref] btTransform getWheelTransformWS(long wheelIndex);
  void updateWheelTransform(long wheelIndex, boolean interpolatedTransform);
  [Ref] btWheelInfo addWheel([Const, Ref] btVector3 connectionPointCS0, [Const, Ref] btVector3 wheelDirectionCS0, [Const, Ref] btVector3 wheelAxleCS, float suspensionRestLength, float wheelRadius, [Const, Ref] btVehicleTuning tuning, boolean isFrontWheel);
  long getNumWheels();
  btRigidBody getRigidBody();
  [Ref] btWheelInfo getWheelInfo(long index);
  void setBrake(float brake, long wheelIndex);
  void setCoordinateSystem(long rightIndex, long upIndex, long forwardIndex);
  float getCurrentSpeedKmHour();
  [Const, Ref] btTransform getChassisWorldTransform();
  float rayCast([Ref] btWheelInfo wheel);
  void updateVehicle(float step);
  void resetSuspension();
  float getSteeringValue(long wheel);
  void updateWheelTransformsWS([Ref] btWheelInfo wheel, optional boolean interpolatedTransform);
  void setPitchControl(float pitch);
  void updateSuspension(float deltaTime);
  void updateFriction(float timeStep);
  long getRightAxis();
  long getUpAxis();
  long getForwardAxis();
  [Value] btVector3 getForwardVector();
  long getUserConstraintType();
  void setUserConstraintType(long userConstraintType);
  void setUserConstraintId(long uid);
  long getUserConstraintId();
};
btRaycastVehicle implements btActionInterface;

interface btGhostObject {
  void btGhostObject();
  long getNumOverlappingObjects();
  btCollisionObject getOverlappingObject(long index);
};
btGhostObject implements btCollisionObject;

interface btPairCachingGhostObject {
  void btPairCachingGhostObject();
};
btPairCachingGhostObject implements btGhostObject;

interface btGhostPairCallback {
  void btGhostPairCallback();
};

// interface btMultiBodyJointFeedback {
// 	[Value] attribute btSpatialForceVector m_reactionForces;
// };

enum btMultibodyLink_eFeatherstoneJointType {
  "btMultibodyLink::eRevolute",
  "btMultibodyLink::ePrismatic",
  "btMultibodyLink::eSpherical",
  "btMultibodyLink::ePlanar",
  "btMultibodyLink::eFixed",
  "btMultibodyLink::eInvalid"
};

interface btMultibodyLink {
	attribute float m_mass;           // mass of link
	[Value] attribute btVector3  m_inertiaLocal;  // inertia of link (local frame; diagonal)

	attribute long m_parent;  // index of the parent link (assumed to be < index of this link), or -1 if parent is the base link.

	[Value] attribute btQuaternion m_zeroRotParentToThis;  // rotates vectors in parent-frame to vectors in local-frame (when q=0). constant.

	[Value] attribute btVector3 m_dVector;  // vector from the inboard joint pos to this link's COM. (local frame.) constant.
						  //this is set to zero for planar joint (see also m_eVector comment)

	// m_eVector is constant, but depends on the joint type:
	// revolute, fixed, prismatic, spherical: vector from parent's COM to the pivot point, in PARENT's frame.
	// planar: vector from COM of parent to COM of this link, WHEN Q = 0. (local frame.)
	// todo: fix the planar so it is consistent with the other joints

	[Value] attribute btVector3 m_eVector;

  [Value] attribute btSpatialMotionVector m_absFrameTotVelocity;
  [Value] attribute btSpatialMotionVector m_absFrameLocVelocity;

	// "axis" = spatial joint axis (Mirtich Defn 9 p104). (expressed in local frame.) constant.
	// for prismatic: m_axesTop[0] = zero;
	//                m_axesBottom[0] = unit vector along the joint axis.
	// for revolute: m_axesTop[0] = unit vector along the rotation axis (u);
	//               m_axesBottom[0] = u cross m_dVector (i.e. COM linear motion due to the rotation at the joint)
	//
	// for spherical: m_axesTop[0][1][2] (u1,u2,u3) form a 3x3 identity matrix (3 rotation axes)
	//				  m_axesBottom[0][1][2] cross u1,u2,u3 (i.e. COM linear motion due to the rotation at the joint)
	//
	// for planar: m_axesTop[0] = unit vector along the rotation axis (u); defines the plane of motion
	//			   m_axesTop[1][2] = zero
	//			   m_axesBottom[0] = zero
	//			   m_axesBottom[1][2] = unit vectors along the translational axes on that plane
	// btSpatialMotionVector m_axes[6];
	void setAxisTop(long dof, [Const, Ref] btVector3 axis);
	void setAxisBottom(long dof, [Const, Ref] btVector3 axis);
	// void setAxisTop(long dof, [Const, Ref] float x, [Const, Ref] float y, [Const, Ref] float z);
	// void setAxisBottom(long dof, [Const, Ref] float x, [Const, Ref] float y, [Const, Ref] float z);
	[Const, Ref] btVector3 getAxisTop(long dof);
	[Const, Ref] btVector3 getAxisBottom(long dof);

	attribute long m_dofOffset;
  attribute long m_cfgOffset;

	[Value] attribute btQuaternion m_cachedRotParentToThis;  // rotates vectors in parent frame to vectors in local frame
	[Value] attribute btVector3 m_cachedRVector;             // vector from COM of parent to COM of this link, in local frame.
    
  // predicted verstion
    // rotates vectors in parent frame to vectors in local frame
          // vector from COM of parent to COM of this link, in local frame.

	[Value] attribute btVector3 m_appliedForce;   // In WORLD frame
	[Value] attribute btVector3 m_appliedTorque;  // In WORLD frame

	// attribute float[7] m_jointPos;
  // attribute float[7] m_jointPos_interpolate;

	//m_jointTorque is the joint torque applied by the user using 'addJointTorque'.
	//It gets set to zero after each internal stepSimulation call
	// attribute float[6] m_jointTorque;

	attribute btMultiBodyLinkCollider m_collider;
	attribute long m_flags;

	attribute long m_dofCount;
  attribute long m_posVarCount;  //redundant but handy

	attribute btMultibodyLink_eFeatherstoneJointType m_jointType;

	// attribute btMultiBodyJointFeedback m_jointFeedback;

	// ctor: set some sensible defaults
	void btMultibodyLink();
};

interface btMultiBodyLinkCollider : btCollisionObject {
	attribute btMultiBody m_multiBody;
	attribute long m_link;

	void btMultiBodyLinkCollider(btMultiBody multiBody, long link);
  [Const] static btMultiBodyLinkCollider upcast([Const] btCollisionObject colObj);
	boolean checkCollideWithOverride([Const] btCollisionObject co);
};
btMultiBodyLinkCollider implements btCollisionObject;

interface btMultiBody {
  void btMultiBody(long n_links,               // NOT including the base
              float mass,                      // mass of base
              [Const, Ref] btVector3 inertia,  // inertia of base, in base frame; assumed diagonal
              boolean fixed_base_,             // whether the base is fixed (true) or can move (false)
              boolean can_sleep_, optional boolean deprecatedMultiDof);

  void setupPrismatic(long i,             // 0 to num_links-1
                      float mass,
                      [Const, Ref] btVector3 inertia,       // in my frame; assumed diagonal
                      long parent,
                      [Const, Ref] btQuaternion rot_parent_to_this,  // rotate points in parent frame to my frame.
                      [Const, Ref] btVector3 joint_axis,             // in my frame
                      [Const, Ref] btVector3 parentComToThisPivotOffset,
                      [Const, Ref] btVector3 thisPivotToThisComOffset,
                      boolean disableParentCollision);

  void setupRevolute(long i,            // 0 to num_links-1
                      float mass,
                      [Const, Ref] btVector3 inertia,
                      long parent,
                      [Const, Ref] btQuaternion zero_rot_parent_to_this,  // rotate points in parent frame to this frame, when q = 0
                      [Const, Ref] btVector3 joint_axis,    // in my frame
                      [Const, Ref] btVector3 parent_axis_position,    // vector from parent COM to joint axis, in PARENT frame
                      [Const, Ref] btVector3 my_axis_position,       // vector from joint axis to my COM, in MY frame
                      optional boolean disableParentCollision);
	
	void setupSpherical(long i,  // linkIndex, 0 to num_links-1
						float mass,
						[Const, Ref] btVector3 inertia,
						long parent,
						[Const, Ref] btQuaternion rotParentToThis,          // rotate points in parent frame to this frame, when q = 0
						[Const, Ref] btVector3 parentComToThisPivotOffset,  // vector from parent COM to joint axis, in PARENT frame
						[Const, Ref] btVector3 thisPivotToThisComOffset,    // vector from joint axis to my COM, in MY frame
						optional boolean disableParentCollision);

	void setupPlanar(long i,  // 0 to num_links-1
					 float mass,
					 [Const, Ref] btVector3 inertia,
					 long parent,
					 [Const, Ref] btQuaternion rotParentToThis,  // rotate points in parent frame to this frame, when q = 0
					 [Const, Ref] btVector3 rotationAxis,
					 [Const, Ref] btVector3 parentComToThisComOffset,  // vector from parent COM to this COM, in PARENT frame
					 optional boolean disableParentCollision = false);

	[Const, Ref] btMultibodyLink getLink(long index);
	// [Ref] btMultibodyLink getLink(long index);

  //collider can be NULL to disable collision for the base
	void setBaseCollider(btMultiBodyLinkCollider collider);
	// [Const] btMultiBodyLinkCollider getBaseCollider();
	btMultiBodyLinkCollider getBaseCollider();


  //
  // get parent
  // input: link num from 0 to num_links-1
  // output: link num from 0 to num_links-1, OR -1 to mean the base.
  //
  long getParent(long link_num);
  
  //
  // get number of links, masses, moments of inertia
  //

  long getNumLinks();
	long getNumDofs();
	long getNumPosVars();
  float getBaseMass();
  [Const, Ref] btVector3 getBaseInertia();
  float getLinkMass(long i);
  [Const, Ref] btVector3 getLinkInertia(long i);
  

  //
  // change mass (incomplete: can only change base mass and inertia at present)
  //

  void setBaseMass(float mass);
  void setBaseInertia([Const, Ref] btVector3 inertia);


  //
  // get/set pos/vel/rot/omega for the base link
  //

  [Const, Ref] btVector3 getBasePos();
  [Const, Value] btVector3 getBaseVel();
  [Const, Ref] btQuaternion getWorldToBaseRot();
  [Value] btVector3 getBaseOmega();

  void setBasePos([Const, Ref] btVector3 pos);
  void setBaseWorldTransform([Const, Ref] btTransform tr);
  void setBaseVel([Const, Ref] btVector3 vel);
  void setWorldToBaseRot([Const, Ref] btQuaternion rot);
  void setBaseOmega([Const, Ref] btVector3 omega);

  //
  // get/set pos/vel for child links (i = 0 to num_links-1)
  //

  float getJointPos(long i);
  float getJointVel(long i);
	// [Const] float* getJointPosMultiDof(long i);
	// [Const] float* getJointVelMultiDof(long i);

	void setJointPos(long i, float q);
	void setJointVel(long i, float qdot);
	// void setJointPosMultiDof(long i, [Const] float* q);
	// void setJointVelMultiDof(long i, [Const] float* qdot);

  //
  // direct access to velocities as a vector of 6 + num_links elements.
  // (omega first, then v, then joint velocities.)
  //
  // [Const] float* getVelocityVector();

  [Const, Ref] btVector3 getRVector(long i);   // vector from COM(parent(i)) to COM(i), in frame i's coords
  [Const, Ref] btQuaternion getParentToLocalRot(long i);   // rotates vectors in frame parent(i) to vectors in frame i.

  [Value] btVector3 localPosToWorld(long i, [Const, Ref] btVector3 vec);
  [Value] btVector3 localDirToWorld(long i, [Const, Ref] btVector3 vec);
  [Value] btVector3 worldPosToLocal(long i, [Const, Ref] btVector3 vec);
  [Value] btVector3 worldDirToLocal(long i, [Const, Ref] btVector3 vec);



  void clearForcesAndTorques();

	void clearVelocities();

  void addBaseForce([Const, Ref] btVector3 f);
  void addBaseTorque([Const, Ref] btVector3 t);
  void addLinkForce(long i, [Const, Ref] btVector3 f);
  void addLinkTorque(long i, [Const, Ref] btVector3 t);



	void addJointTorque(long i, float Q);
	void addJointTorqueMultiDof(long i, long dof, float Q);

	[Const, Ref] btVector3 getBaseForce();
	[Const, Ref] btVector3 getBaseTorque();
	[Const, Ref] btVector3 getLinkForce(long i);
	[Const, Ref] btVector3 getLinkTorque(long i);
	float getJointTorque(long i);
	// float* getJointTorqueMultiDof(long i);


  //
  // dynamics routines.
  //

  // timestep the velocities (given the external forces/torques set using addBaseForce etc).
  // also sets up caches for calcAccelerationDeltas.
  //
  // Note: the caller must provide three vectors which are used as
  // temporary scratch space. The idea here is to reduce dynamic
  // memory allocation: the same scratch vectors can be re-used
  // again and again for different Multibodies, instead of each
  // btMultiBody allocating (and then deallocating) their own
  // individual scratch buffers. This gives a considerable speed
  // improvement, at least on Windows (where dynamic memory
  // allocation appears to be fairly slow).
  


  void setCanSleep(boolean canSleep);
	boolean getCanSleep();
  boolean isAwake();
  void wakeUp();
  void goToSleep();
  void checkMotionAndSleepIfRequired(float timestep);
    
	boolean hasFixedBase();

	long getCompanionId();
	void setCompanionId(long id);
	void setNumLinks(long numLinks); //careful: when changing the number of links, make sure to re-initialize or update existing links
	float getLinearDamping();
	void setLinearDamping(float damp);
	float getAngularDamping();
  void setAngularDamping(float damp);
	boolean getUseGyroTerm();
	void setUseGyroTerm(boolean useGyro);
  float getMaxCoordinateVelocity();
  void setMaxCoordinateVelocity(float maxVel);
	float getMaxAppliedImpulse();
	void setMaxAppliedImpulse(float maxImp);

	void setHasSelfCollision(boolean hasSelfCollision);
	boolean hasSelfCollision();

	void finalizeMultiDof();

	void useRK4Integration(boolean use);
	boolean isUsingRK4Integration();
	void useGlobalVelocities(boolean use);
	boolean isUsingGlobalVelocities();
};

interface btMultiBodyJacobianData {
	[Value] attribute btScalarArray		  m_jacobians;
	[Value] attribute btScalarArray		  m_deltaVelocitiesUnitImpulse;
	[Value] attribute btScalarArray		  m_deltaVelocities;
	[Value] attribute btScalarArray		  scratch_r;
	[Value] attribute btVector3Array		scratch_v;
	[Value] attribute btMatrix3x3Array	scratch_m;
	attribute btSolverBodyArray 	      m_solverBodyPool;
	attribute long									    m_fixedBodyId;
};

interface btMultiBodyConstraint {
	// void btMultiBodyConstraint(btMultiBody bodyA, btMultiBody bodyB,long linkA, long linkB, long numRows, boolean isUnilateral);

	long getIslandIdA();
	long getIslandIdB();
	
	// void createConstraintRows([Ref] btMultiBodyConstraintArray constraintRows,
	// 	[Ref] btMultiBodyJacobianData data,
	// 	[Const, Ref] btContactSolverInfo infoGlobal);

	long getNumRows();
	btMultiBody getMultiBodyA();
  btMultiBody	getMultiBodyB();

	// current constraint position
  // constraint is pos >= 0 for unilateral, or pos = 0 for bilateral
  // NOTE: ignored position for friction rows.
  float getPosition(long row);
  void setPosition(long row, float pos);

	boolean isUnilateral();

	// jacobian blocks.
  // each of size 6 + num_links. (jacobian2 is null if no body2.)
  // format: 3 'omega' coefficients, 3 'v' coefficients, then the 'qdot' coefficients.
  // float* jacobianA(long row);
  // [Const] float* jacobianA(long row);
  // float* jacobianB(long row);
  // [Const] float* jacobianB(long row);
	float	getMaxAppliedImpulse();
	void	setMaxAppliedImpulse(float maxImp);
};

interface btMultiBodyConstraintSolver : btSequentialImpulseConstraintSolver {
  void btMultiBodyConstraintSolver();
	// void solveMultiBodyGroup(btCollisionObject* bodies, long numBodies, btPersistentManifold* manifold,long numManifolds,btTypedConstraint* constraints,long numConstraints,btMultiBodyConstraint* multiBodyConstraints, long numMultiBodyConstraints, [Const, Ref] btContactSolverInfo info, btIDebugDraw debugDrawer, btDispatcher dispatcher);
};
btMultiBodyConstraintSolver implements btSequentialImpulseConstraintSolver;

interface btMultiBodyDynamicsWorld : btDiscreteDynamicsWorld {
	void btMultiBodyDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);
	
	void addMultiBody(btMultiBody body, short group, short mask);
	void removeMultiBody(btMultiBody body);
	void addMultiBodyConstraint( btMultiBodyConstraint constraint);
	void removeMultiBodyConstraint( btMultiBodyConstraint constraint);
};
btMultiBodyDynamicsWorld implements btDiscreteDynamicsWorld;

interface btMultiBodyJointLimitConstraint : btMultiBodyConstraint {
	void btMultiBodyJointLimitConstraint(btMultiBody body, long link, float lower, float upper);

  void finalizeMultiDof();

	long getIslandIdA();
	long getIslandIdB();

	void createConstraintRows([Ref] btMultiBodyConstraintArray constraintRows,
		[Ref] btMultiBodyJacobianData data,
		[Const, Ref] btContactSolverInfo infoGlobal);
};
btMultiBodyJointLimitConstraint implements btMultiBodyConstraint;

interface btMultiBodyJointMotor : btMultiBodyConstraint {
	void btMultiBodyJointMotor(btMultiBody body, long link, long linkDoF, float desiredVelocity, float maxMotorImpulse);

  void finalizeMultiDof();

	long getIslandIdA();
	long getIslandIdB();

	void createConstraintRows([Ref] btMultiBodyConstraintArray constraintRows,
		[Ref] btMultiBodyJacobianData data,
		[Const, Ref] btContactSolverInfo infoGlobal);

  void setVelocityTarget(float velTarget);
};
btMultiBodyJointMotor implements btMultiBodyConstraint;

interface btMultiBodyPoint2Point : btMultiBodyConstraint {
	void btMultiBodyPoint2Point(btMultiBody body, long link, btRigidBody bodyB, [Const, Ref] btVector3 pivotInA, [Const, Ref] btVector3 pivotInB);
	void btMultiBodyPoint2Point(btMultiBody bodyA, long linkA, btMultiBody bodyB, long linkB, [Const, Ref] btVector3 pivotInA, [Const, Ref] btVector3 pivotInB);

	void finalizeMultiDof();

	long getIslandIdA();
	long getIslandIdB();

	void createConstraintRows([Ref] btMultiBodyConstraintArray constraintRows,
		[Ref] btMultiBodyJacobianData data,
		[Const, Ref] btContactSolverInfo infoGlobal);

	[Const, Ref] btVector3 getPivotInB();
	void setPivotInB([Const, Ref] btVector3 pivotInB);
};
btMultiBodyPoint2Point implements btMultiBodyConstraint;

interface btMultiBodySolverConstraint {
	attribute long				m_deltaVelAindex;//more generic version of m_relpos1CrossNormal/m_contactNormal1
	[Value] attribute btVector3		m_relpos1CrossNormal;
	[Value] attribute btVector3		m_contactNormal1;
	attribute long				m_jacAindex;

	attribute long				m_deltaVelBindex;
	[Value] attribute btVector3		m_contactNormal2; //usually m_contactNormal2 == -m_contactNormal1, but not always
	[Value] attribute btVector3		m_relpos2CrossNormal;
	attribute long				m_jacBindex;

	[Value] attribute btVector3		m_angularComponentA;
	[Value] attribute btVector3		m_angularComponentB;
	
	// mutable btSimdScalar	m_appliedPushImpulse;
	// mutable btSimdScalar	m_appliedImpulse;

	attribute float	m_friction;
	attribute float	m_jacDiagABInv;
	attribute float		m_rhs;
	attribute float		m_cfm;
	
  attribute float		m_lowerLimit;
	attribute float		m_upperLimit;
	attribute float		m_rhsPenetration;

	attribute long	m_overrideNumSolverIterations;
  attribute long			m_frictionIndex;

	attribute long m_solverBodyIdA;
	attribute btMultiBody m_multiBodyA;
	attribute long			m_linkA;
	
	attribute long m_solverBodyIdB;
	attribute btMultiBody m_multiBodyB;
	attribute long			m_linkB;
};

// enum btMultiBodySolverConstraint_btSolverConstraintType {
//   "btMultiBodySolverConstraint::BT_SOLVER_CONTACT_1D",
//   "btMultiBodySolverConstraint::BT_SOLVER_FRICTION_1D"
// };

interface	btMultiBodyConstraintArray {
  void btMultiBodyConstraintArray();
  long size();
  [Const, Ref] btMultiBodySolverConstraint at(long n);
  void clear();
  void pop_back();
  void resize(long newsize, [Const, Ref] btMultiBodySolverConstraint? fillData);
  [Ref] btMultiBodySolverConstraint expandNonInitializing();
  [Ref] btMultiBodySolverConstraint expand([Const, Ref] btMultiBodySolverConstraint? fillValue);
  void push_back([Const, Ref] btMultiBodySolverConstraint _Val);
  long capacity();
  void reserve(long _Count);
};

interface btMLCPSolverInterface {
	//return true is it solves the problem successfully
	// boolean solveMLCP([Const, Ref] btMatrixXu A, [Const, Ref] btVectorXu b, [Ref] btVectorXu x, [Const, Ref] btVectorXu lo, [Const, Ref] btVectorXu hi, [Const, Ref] btAlignedObjectArray<int> limitDependency, long numIterations, boolean useSparsity);
};

interface btDantzigSolver : btMLCPSolverInterface {
  void btDantzigSolver();
};
btDantzigSolver implements btMLCPSolverInterface;

interface btSolveProjectedGaussSeidel : btMLCPSolverInterface {
  void btSolveProjectedGaussSeidel();
};
btSolveProjectedGaussSeidel implements btMLCPSolverInterface;

interface btLemkeSolver : btMLCPSolverInterface {
  void btLemkeSolver();
};
btLemkeSolver implements btMLCPSolverInterface;

interface btMLCPSolver : btSequentialImpulseConstraintSolver {
	void btMLCPSolver(btMLCPSolverInterface solver);
	
	void setMLCPSolver(btMLCPSolverInterface solver);

	long getNumFallbacks();
	void setNumFallbacks(long num);

	btConstraintSolverType getSolverType();
};
btMLCPSolver implements btSequentialImpulseConstraintSolver;

// soft bodies

interface btSoftBodyWorldInfo {
  void btSoftBodyWorldInfo();
  attribute float air_density;
  attribute float water_density;
  attribute float water_offset;
  attribute float m_maxDisplacement;
  [Value] attribute btVector3 water_normal;
  attribute btBroadphaseInterface m_broadphase;
  attribute btDispatcher m_dispatcher;
  [Value] attribute btVector3 m_gravity;
};

[Prefix="btSoftBody::"]
interface Face {
  attribute Node[] m_n;
  [Value] attribute btVector3 m_normal;
  attribute float m_ra;
};

[Prefix="btSoftBody::"]
interface tFaceArray {
  [Const] long size();
  [Const, Ref] Face at(long n);
};

[Prefix="btSoftBody::"]
interface Node {
  [Value] attribute btVector3 m_x;
  [Value] attribute btVector3 m_q;
  [Value] attribute btVector3 m_v;
  [Value] attribute btVector3 m_f;
  [Value] attribute btVector3 m_n;
  attribute float m_im;
  attribute float m_area;
};

[Prefix="btSoftBody::"]
interface tNodeArray {
  [Const] long size();
  [Const, Ref] Node at(long n);
};

[Prefix="btSoftBody::"]
interface Material {
  attribute float m_kLST;
  attribute float m_kAST;
  attribute float m_kVST;
  attribute long m_flags;
};

[Prefix="btSoftBody::"]
interface tMaterialArray {
  [Const] long size();
  Material at(long n);
};

[Prefix="btSoftBody::"]
interface Anchor {
  attribute Node m_node;
  [Value] attribute btVector3 m_local;
  attribute btRigidBody m_body;
  attribute float m_influence;
  [Value] attribute btMatrix3x3 m_c0;
  [Value] attribute btVector3 m_c1;
  attribute float m_c2;
};

[Prefix="btSoftBody::"]
interface tAnchorArray {
  [Const] long size();
  [Value] Anchor at(long n);
  void clear();
  void push_back([Ref] Anchor val);
  void pop_back();
};

[Prefix="btSoftBody::"]
interface Config {
  attribute float kVCF;
  attribute float kDP;
  attribute float kDG;
  attribute float kLF;
  attribute float kPR;
  attribute float kVC;
  attribute float kDF;
  attribute float kMT;
  attribute float kCHR;
  attribute float kKHR;
  attribute float kSHR;
  attribute float kAHR;
  attribute float kSRHR_CL;
  attribute float kSKHR_CL;
  attribute float kSSHR_CL;
  attribute float kSR_SPLT_CL;
  attribute float kSK_SPLT_CL;
  attribute float kSS_SPLT_CL;
  attribute float maxvolume;
  attribute float timescale;
  attribute long viterations;
  attribute long piterations;
  attribute long diterations;
  attribute long citerations;
  attribute long collisions;
};

interface btSoftBody {
  void btSoftBody(btSoftBodyWorldInfo worldInfo, long node_count, btVector3 x, float[] m);

  [Value] attribute Config m_cfg;
  [Value] attribute tNodeArray m_nodes;
  [Value] attribute tFaceArray m_faces;
  [Value] attribute tMaterialArray m_materials;
  [Value] attribute tAnchorArray m_anchors;

  [Const] boolean checkLink( long node0, long node1);
  [Const] boolean checkFace( long node0, long node1, long node2);
  Material appendMaterial();
  void appendNode( [Const, Ref] btVector3 x, float m);
  void appendLink( long node0, long node1, Material mat, boolean bcheckexist);
  void appendFace( long node0, long node1, long node2, Material mat);
  void appendTetra( long node0, long node1, long node2, long node3, Material mat);
  void appendAnchor( long node, btRigidBody body, boolean disableCollisionBetweenLinkedBodies, float influence);
  void addForce([Const, Ref] btVector3 force);
  void addForce([Const, Ref] btVector3 force, long node);
  void addAeroForceToNode([Const, Ref] btVector3 windVelocity, long nodeIndex);
  [Const] float getTotalMass();
  void setTotalMass( float mass, boolean fromfaces);
  void setMass(long node, float mass);
  void transform( [Const, Ref] btTransform trs);
  void translate( [Const, Ref] btVector3 trs);
  void rotate( [Const, Ref] btQuaternion rot);
  void scale(  [Const, Ref] btVector3 scl);
  long generateClusters(long k, optional long maxiterations);
  long generateBendingConstraints(long distance, Material mat);
  btSoftBody upcast(btCollisionObject colObj);
  float getRestLengthScale();
  void setRestLengthScale(float restLength);
};
btSoftBody implements btCollisionObject;

interface btSoftBodyRigidBodyCollisionConfiguration {
  void btSoftBodyRigidBodyCollisionConfiguration([Ref] optional btDefaultCollisionConstructionInfo info);
};
btSoftBodyRigidBodyCollisionConfiguration implements btDefaultCollisionConfiguration;

interface btSoftBodySolver {
};

interface btDefaultSoftBodySolver {
  void btDefaultSoftBodySolver ();
};
btDefaultSoftBodySolver implements btSoftBodySolver;

interface btSoftBodyArray {
  [Const] long size();
  [Const] btSoftBody at(long n);
};

interface btSoftRigidDynamicsWorld {
  void btSoftRigidDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, btSoftBodySolver softBodySolver);

  void addSoftBody(btSoftBody body, short collisionFilterGroup, short collisionFilterMask);
  void removeSoftBody(btSoftBody body);
  void removeCollisionObject(btCollisionObject collisionObject);

  [Ref] btSoftBodyWorldInfo getWorldInfo();
  [Ref] btSoftBodyArray getSoftBodyArray();
};
btSoftRigidDynamicsWorld implements btDiscreteDynamicsWorld;

interface btSoftBodyHelpers {
  void btSoftBodyHelpers();

  btSoftBody CreateRope([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 from, [Const, Ref] btVector3 to, long res, long fixeds);
  btSoftBody CreatePatch([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags);
  btSoftBody CreatePatchUV([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags, float[] tex_coords);
  btSoftBody CreateEllipsoid([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 center, [Const, Ref] btVector3 radius, long res);
  btSoftBody CreateFromTriMesh([Ref] btSoftBodyWorldInfo worldInfo, float[] vertices, long[] triangles, long ntriangles, boolean randomizeConstraints);
  btSoftBody CreateFromConvexHull([Ref] btSoftBodyWorldInfo worldInfo, [Const] btVector3 vertices, long nvertices, boolean randomizeConstraints);
};
